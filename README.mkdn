OmniROM Hardware Abstraction Framework
==========================================

What's this?
------------

It's a simple library with a set of classes to access hardware tunables
and properties that tend to vary from platform to platform, or device to
device, but are still useful to present functionality to the end user.
Examples of these tunables are display color calibration, processor eco
modes, vibration strength, sensor reset/recalibrate, etc.

The library should present a common interface and completely abstract
implementation details so that the UI part of said functionality (the
knobs and buttons users actually interact with) can be implemented at
a single location on any shipped platform app (typically, Settings). No
UI or layout elements should be included in here.

How do I use it?
----------------

Classes present in this repository are for basic hardware tunables support.
They are designed so that device maintainers should be able to easily edit 
XML config files in order to activate variables hardware features, as appropriate
for their device. These classes should fully implementthe expected API
that'll be used in Settings. 

Each device is also capable of implementing its own classes for supported 
hardware tunables which need an unorthodox/custom implementation. The existence
of such classes should be signaled by adding a BOARD_HARDWARE_CLASS 
variable to its BoardConfig, pointing to the path where said classes
can be found. The Nexus4, for instance, has

BOARD_HARDWARE_CLASS := device/lge/mako/omnihw/

Every class present in this framework addresses a single tunable;
Devices which require custom classes MUST implement ALL methods that exist
in the defualt implementation, as the client applications will expect them to
be present.

Wouldn't it be better if...?
----------------------------

Suggestions are always welcome. The choices made in this implementation were
based on the fact that we aimed to make life easier for device maintainers by
having them work with a simple XML format rather than Java. Obviously, the
default classes will not satisfy every device out there, which is why the
overloading option is present.
